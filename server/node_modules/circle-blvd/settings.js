// settings.js
var db    = require('./dataAccess.js').instance();
var async = require('async');

module.exports = function () {
	
	var set = function (settings, fnCallback) {
		var tasks = [];
		settings.forEach(function (setting) {
			tasks.push(function (callback) {
				db.settings.update(setting, callback);				
			});
		});
		async.parallel(tasks, fnCallback);
	};

	var init = function (settings, callback) {
		var settingsTable = {};
		var initialized = {};
		settings.forEach(function (setting) {
			settingsTable[setting.name] = setting;
			initialized[setting.name] = undefined;
		});

		var callbackIfAllSettingsReady = function () {
			var isReady = true;
			for (var key in initialized) {
				if (initialized[key] === undefined) {
					isReady = false;
					break;
				}
			}

			if (isReady && callback) {
				callback(null, initialized);
			}
		};

		db.settings.getAll(function (err, savedSettings) {
			if (err) {
				return callback(err);
			}
			// var savedSetting;
			// var defaultSetting;
			var settingFound;
			var settingReady = function (setting) {
				initialized[setting.name] = setting;
				callbackIfAllSettingsReady();
			};

			for (var defaultName in settingsTable) {
				
				settingFound = false;
				for (var savedName in savedSettings) {
					if (savedName === defaultName) {
						settingFound = true;
						break;
					}
				}

				if (!settingFound) {
					var addSettingToDatabase = function (settingToAdd) {
						db.settings.add(settingToAdd, function (err, body) {
							if (err) {
								return callback({
									message: "Could not set setting: " + settingToAdd.name
								});
							}
							settingReady(settingToAdd);
						});
					}(settingsTable[defaultName]);				
				}
				else {
					settingReady(savedSettings[savedName]);
				}
			}
		});
	};

	var initWhenReady = function (settings, callback) {
		var tenSeconds = 10000;
		db.whenReady(function () {
			init(settings, callback);
		}, tenSeconds);
		// TODO: Do we need to wait a little bit to ensure the
		// servers are started before our thread exits?		
	};

	return {
		init: initWhenReady,
		set: set
	};
}();