// Send events to Slack webhooks
var express = require('express');
var guard   = require('@holmwell/errors').guard;
var request = require('request');

var middleware = function (db) {
    var router = express.Router();

    var getSlackUrl = function (circle) {
        if (circle && circle.webhooks && circle.webhooks.slack) {
            return circle.webhooks.slack.url;
        }
    }

    var getCircleId = function (res) {
        // Use the SocketIO data we've already put on the response object.
        if (res.circleBlvd && res.circleBlvd.notifyCircle) {
            return res.circleBlvd.notifyCircle;
        }
    }

    var logError = function (err) {
        console.log(err);
    };

    var getTaskSummary = function (story) {
        var assigned = story.status ? "" : "?";
        var owner = story.owner ? " @" + story.owner + assigned : "";

        return story.summary + owner;
    };

    var getTaskMessage = function (message, story) {
        return message + ': ' + getTaskSummary(story);
    };

    var getNewTaskMessage = function (story) {
        var adjective = "new task";
        if (story.status === 'done') {
            adjective = "done";
        }
        return getTaskMessage(adjective, story); 
    };

    var getSavedTaskMessage = function (story) {
        var old = story._previousValue;

        if (old && old.status !== story.status) {
            if (story.status === 'done') {
                return getTaskMessage('done', story);
            }
            if (story.status === 'active') {
                return getTaskMessage('on it', story);
            }
            if (story.status === 'sad') {
                return getTaskMessage('maybe needs help', story);
            }

            if (story.status === 'assigned' || !story.status) {
                if (old.status === 'sad') {
                    return getTaskMessage('no longer needs help', story);
                }
                if (old.status === 'active') {
                    return getTaskMessage('no longer active', story);
                }
                if (old.status === 'done') {
                    return getTaskMessage('no longer done', story);
                }
            }
        }

        if (old && old.owner !== story.owner) {
            if (story.owner) {
                return getTaskMessage('new assignment', story);
            }
        }

        return null;
    };

    var sendSlackMessages = function (res) {
        var circleId = getCircleId(res);
        if (!circleId) {
            // Nothing to do
            return;
        }

        db.docs.get(circleId, guard(logError, function (circle) {
            var slackUrl = getSlackUrl(circle);
            if (!slackUrl) {
                // Nothing to do
                return;
            }

            var text = undefined;

            switch (res.circleBlvd.notifyType) {
                case 'story-add':
                    text = getNewTaskMessage(res.circleBlvd.notifyData);
                    break;
                case 'story-save':
                    text = getSavedTaskMessage(res.circleBlvd.notifyData);
                    break;
            }

            if (!text) {
                // We don't have a Slack message for the action at hand.
                return;
            }

            var slackPayload = {
                json: {
                    text: text
                }
            };

            request.post(slackUrl, slackPayload, function (err, response, body) {
                // TODO: Not sure who to notify ... 
                if (err) {
                    console.log(err);
                    return;
                }

                // if (response.statusCode === 200) {
                //     console.log(body)
                // }
            });
        }));
    };


    function slackWebhookMiddleware(req, res, next) {
        res.on('finish', function () {
            sendSlackMessages(res);
        });
        next();
    }

    router.use(slackWebhookMiddleware);

    return router;
};

module.exports = middleware;